# Support Vector Machine (SVM) Classification
                                                                          # Set up your data:
x = np.array([[5,2], [3,6], [2,7], [1,6], [5,3], [3.5,4], [4,3]])              # Set up x array
y_orig = np.array([-1, 1, 1, 1, -1, -1, -1])                                   # Set up y_orig into an array containing equal elements to x, but is either 1 or -1
x

# Perceptron
                                                                          #                                                                             
L = y_orig.size                                                               # Generate the size of y_orig (7 elements) and store into var L
X1 = x[:,0].reshape(L,1)                                                      # select every 1st element of x and store into array with dimension of (rows, column) = (L, 1). Store result into X1 
X2 = x[:,1].reshape(L,1)                                                      # same as above, except 2nd element. Store into X2
y = y_orig.reshape(L,1)                                                       # Store y_orig into arrays of (L, 1). 

w0, w1, w2 = 1, 0, 0 #Creating our weights, start at 0 for 1st iteration

count = 0 #Counter to go through each point
iteration = 1 #Number of iterations

alpha = 0.01 #learning rate
while(iteration<1000):
    y_pred = w0 + w1 * X1 + w2 * X2 # The current prediction
    prod = y_pred*y # Calculate product to see whether correct
    #(If > 1, the prediction is correct)
    for val in prod: # go through all of product
        if(val<=1): # if the prediction incorrect
            w0 = w0 + alpha * y[count] #nudge w vect in right direction
            w1 = w1 + alpha*y[count]*X1[count]
            w2 = w2 + alpha*y[count]*X2[count]
        count += 1
    count = 0
    iteration += 1
    
print('w0', w0)
print('w1', w1)
print('w2', w2)

y = w0 + w1*X1 + w2*X2
